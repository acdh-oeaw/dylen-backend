type Query {
    allAvailableCorpora: [String]
    getNetwork(targetword_id: String, year: Int): EgoNetwork
    getSourcesByCorpus(corpus: String): [String]
    getTargetWordById(targetword_id: String): TargetWord
    getNetworksByCorpusAndSource(corpus:String, source: String, page: Int, size: Int): TargetWordsSliceDto
    getAutocompleteSuggestions(corpus:String, source: String, searchTerm: String, page:Int, size:Int): [Suggestion]
}
type SuggestionSliceDto {
    sliceNumber: Int
    hasNext: Boolean
    suggestions: [Suggestion]
}
type TargetWordsSliceDto {
    sliceNumber: Int
    hasNext: Boolean
    targetWords: [TargetWord]
}

type Suggestion {
    id: String
    corpus: String
    source: String
    pos: String
    text: String
}

type TargetWord {
    id: ID
    text: String
    pos: String
    networks: [EgoNetwork]
    timeSeries: TimeSeries
}

type Corpus {
    id: ID
    name: String
    sources: [Source]
}

type Source {
    name: String
    targetWords: [TargetWord]
}

type EgoNetwork {
    id: ID
    year: Int
    nodes:[Node]
    edges:[Edge]
}

type TimeSeries {
    freqDiffNorm: TimeSerieMetric
    frobeniusSimilarity: TimeSerieMetric
    jaccardSimilarity: TimeSerieMetric
    rankdcgSimilarity: TimeSerieMetric
    localNeighbourhoodSimilarity: TimeSerieMetric
}

type TimeSerieMetric {
    firstYear: [Float]
    lastYear: [Float]
    previousYear: [Float]
}

type Node {
    id: ID
    clusterId: Int
    text: String
    pos: String
    similarity: Float
    metrics: NodeMetric
}

type NodeMetric {
    degreeCentrality: Float
    closenessCentrality: Float
    betweennessCentrality: Float
    eigenvectorCentrality: Float
    pagerank: Float
    loadCentrality: Float
    harmonicCentrality: Float
    clusteringCoefficient: Float
}

type Edge {
    id: ID
    node1: ID
    node2: ID
    similarity: Float
}